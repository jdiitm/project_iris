-module(iris_proto_pbt).

%% =============================================================================
%% Property-Based Tests for iris_proto
%% =============================================================================
%% Uses PropEr for protocol fuzzing and invariant verification.
%% Run with: proper:quickcheck(iris_proto_pbt:prop_decode_never_crashes()).
%% =============================================================================

-include_lib("proper/include/proper.hrl").
-include_lib("eunit/include/eunit.hrl").

-export([prop_decode_never_crashes/0, prop_login_roundtrip/0, 
         prop_message_roundtrip/0, prop_ack_roundtrip/0,
         prop_oversized_rejected/0]).

%% =============================================================================
%% Generators
%% =============================================================================

%% Generate valid username (1-256 bytes)
gen_username() ->
    ?LET(Len, range(1, 256),
         binary(Len)).

%% Generate short username for roundtrip tests
gen_short_username() ->
    ?LET(Len, range(1, 64),
         binary(Len)).

%% Generate valid target name (1-256 bytes)
gen_target() ->
    ?LET(Len, range(1, 256),
         binary(Len)).

%% Generate valid message (1-65536 bytes)
gen_message() ->
    ?LET(Len, range(1, 1024),  %% Keep small for test speed
         binary(Len)).

%% Generate valid message ID (1-64 bytes)
gen_msgid() ->
    ?LET(Len, range(1, 64),
         binary(Len)).

%% Generate arbitrary binary (fuzz input)
gen_arbitrary_binary() ->
    ?LET(Len, range(0, 1024),
         binary(Len)).

%% Generate malformed packet (random bytes starting with valid opcode)
gen_malformed_packet() ->
    ?LET({Opcode, Garbage}, {range(1, 6), gen_arbitrary_binary()},
         <<Opcode:8, Garbage/binary>>).

%% =============================================================================
%% Properties
%% =============================================================================

%% Property: decode never crashes on any input
prop_decode_never_crashes() ->
    ?FORALL(Bin, gen_arbitrary_binary(),
        begin
            Result = (catch iris_proto:decode(Bin)),
            case Result of
                {'EXIT', _} -> false;  %% Crash = failure
                _ -> true              %% Any result = success
            end
        end).

%% Property: login encode/decode roundtrip
prop_login_roundtrip() ->
    ?FORALL(User, gen_short_username(),
        begin
            Packet = <<1, User/binary>>,
            case iris_proto:decode(Packet) of
                {{login, DecodedUser}, <<>>} ->
                    DecodedUser =:= User;
                _ ->
                    false
            end
        end).

%% Property: message encode/decode roundtrip
prop_message_roundtrip() ->
    ?FORALL({Target, Msg}, {gen_target(), gen_message()},
        begin
            TargetLen = byte_size(Target),
            MsgLen = byte_size(Msg),
            Packet = <<2, TargetLen:16, Target/binary, MsgLen:16, Msg/binary>>,
            case iris_proto:decode(Packet) of
                {{send_message, DecodedTarget, DecodedMsg}, <<>>} ->
                    DecodedTarget =:= Target andalso DecodedMsg =:= Msg;
                _ ->
                    false
            end
        end).

%% Property: ack encode/decode roundtrip
prop_ack_roundtrip() ->
    ?FORALL(MsgId, gen_msgid(),
        begin
            Packet = <<3, MsgId/binary>>,
            case iris_proto:decode(Packet) of
                {{ack, DecodedMsgId}, <<>>} ->
                    DecodedMsgId =:= MsgId;
                _ ->
                    false
            end
        end).

%% Property: oversized inputs are rejected, not accepted
prop_oversized_rejected() ->
    ?FORALL(ExtraLen, range(1, 100),
        begin
            %% Generate username that exceeds max (256 bytes)
            OversizedUser = binary(257 + ExtraLen),
            Packet = <<1, OversizedUser/binary>>,
            case iris_proto:decode(Packet) of
                {{error, username_too_long}, _} -> true;
                _ -> false  %% Should have been rejected
            end
        end).

%% =============================================================================
%% EUnit Test Wrappers (run via make test)
%% =============================================================================

%% Run quick PBT checks (100 cases each)
decode_never_crashes_test() ->
    ?assert(proper:quickcheck(prop_decode_never_crashes(), [{numtests, 100}, quiet])).

login_roundtrip_test() ->
    ?assert(proper:quickcheck(prop_login_roundtrip(), [{numtests, 100}, quiet])).

message_roundtrip_test() ->
    ?assert(proper:quickcheck(prop_message_roundtrip(), [{numtests, 100}, quiet])).

ack_roundtrip_test() ->
    ?assert(proper:quickcheck(prop_ack_roundtrip(), [{numtests, 100}, quiet])).

oversized_rejected_test() ->
    ?assert(proper:quickcheck(prop_oversized_rejected(), [{numtests, 50}, quiet])).

%% =============================================================================
%% Manual comprehensive test (run separately)
%% =============================================================================

run_full_pbt() ->
    io:format("Running comprehensive PBT suite (1000 tests each)...~n"),
    Results = [
        {decode_never_crashes, proper:quickcheck(prop_decode_never_crashes(), [{numtests, 1000}])},
        {login_roundtrip, proper:quickcheck(prop_login_roundtrip(), [{numtests, 1000}])},
        {message_roundtrip, proper:quickcheck(prop_message_roundtrip(), [{numtests, 1000}])},
        {ack_roundtrip, proper:quickcheck(prop_ack_roundtrip(), [{numtests, 1000}])},
        {oversized_rejected, proper:quickcheck(prop_oversized_rejected(), [{numtests, 200}])}
    ],
    Passed = length([R || {_, R} <- Results, R =:= true]),
    Total = length(Results),
    io:format("~nPBT Results: ~p/~p passed~n", [Passed, Total]),
    case Passed =:= Total of
        true -> ok;
        false -> {failed, [Name || {Name, R} <- Results, R =/= true]}
    end.
